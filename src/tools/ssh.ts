import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { z } from 'zod';
import { SSHService, SSHConnectionConfig, ConnectionStatus, TerminalSession, FileTransferInfo, BatchTransferConfig, TunnelConfig, CommandResult } from './ssh-service.js';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { createHash } from 'crypto';

export class SshMCP {
  private server: McpServer;
  private sshService: SSHService;
  private activeConnections: Map<string, Date> = new Map();
  private backgroundExecutions: Map<string, { interval: NodeJS.Timeout, lastCheck: Date }> = new Map();

  constructor() {
    // ÂàùÂßãÂåñSSHÊúçÂä°
    this.sshService = new SSHService();

    // ÂàùÂßãÂåñMCPÊúçÂä°Âô®
    this.server = new McpServer({
      name: "ssh-mcp",
      version: "1.0.0"
    });

    // Ê≥®ÂÜåÂ∑•ÂÖ∑
    this.registerTools();

    // ËøûÊé•Âà∞Ê†áÂáÜËæìÂÖ•/ËæìÂá∫
    const transport = new StdioServerTransport();
    this.server.connect(transport).catch(err => {
      console.error('ËøûÊé•MCP‰º†ËæìÈîôËØØ:', err);
    });
  }

  /**
   * Ê≥®ÂÜåÊâÄÊúâMCPÂ∑•ÂÖ∑
   */
  private registerTools(): void {
    // ËøûÊé•ÁÆ°ÁêÜ
    this.registerConnectionTools();
    
    // ÂëΩ‰ª§ÊâßË°å
    this.registerCommandTools();
    
    // Êñá‰ª∂‰º†Ëæì
    this.registerFileTools();
    
    // ‰ºöËØùÁÆ°ÁêÜ
    this.registerSessionTools();
    
    // ÁªàÁ´Ø‰∫§‰∫í
    this.registerTerminalTools();

    // ÈößÈÅìÁÆ°ÁêÜ
    this.registerTunnelTools();
  }

  /**
   * Ê†ºÂºèÂåñËøûÊé•‰ø°ÊÅØËæìÂá∫
   */
  private formatConnectionInfo(connection: any, includePassword: boolean = false): string {
    const statusEmoji = {
      [ConnectionStatus.CONNECTED]: 'üü¢',
      [ConnectionStatus.CONNECTING]: 'üü°',
      [ConnectionStatus.DISCONNECTED]: '‚ö™',
      [ConnectionStatus.RECONNECTING]: 'üü†',
      [ConnectionStatus.ERROR]: 'üî¥'
    };
    
    const statusText = {
      [ConnectionStatus.CONNECTED]: 'Â∑≤ËøûÊé•',
      [ConnectionStatus.CONNECTING]: 'ËøûÊé•‰∏≠',
      [ConnectionStatus.DISCONNECTED]: 'Â∑≤Êñ≠ÂºÄ',
      [ConnectionStatus.RECONNECTING]: 'ÈáçËøû‰∏≠',
      [ConnectionStatus.ERROR]: 'ÈîôËØØ'
    };

    let info = `${statusEmoji[connection.status as ConnectionStatus]} ${connection.name || connection.id}\n`;
    info += `ID: ${connection.id}\n`;
    info += `‰∏ªÊú∫: ${connection.config.host}:${connection.config.port || 22}\n`;
    info += `Áî®Êà∑Âêç: ${connection.config.username}\n`;
    
    if (includePassword && connection.config.password) {
      info += `ÂØÜÁ†Å: ${'*'.repeat(connection.config.password.length)}\n`;
    }
    
    if (connection.config.privateKey) {
      info += `ÁßÅÈí•ËÆ§ËØÅ: ÊòØ\n`;
    }
    
    info += `Áä∂ÊÄÅ: ${statusText[connection.status as ConnectionStatus]}\n`;
    
    if (connection.lastError) {
      info += `ÊúÄËøëÈîôËØØ: ${connection.lastError}\n`;
    }
    
    if (connection.lastUsed) {
      info += `ÊúÄÂêé‰ΩøÁî®: ${connection.lastUsed.toLocaleString()}\n`;
    }
    
    if (connection.currentDirectory) {
      info += `ÂΩìÂâçÁõÆÂΩï: ${connection.currentDirectory}\n`;
    }
    
    if (connection.tags && connection.tags.length > 0) {
      info += `Ê†áÁ≠æ: ${connection.tags.join(', ')}\n`;
    }
    
    if (this.activeConnections.has(connection.id)) {
      const lastActive = this.activeConnections.get(connection.id);
      if (lastActive) {
        info += `Ê¥ªË∑ÉÂ∫¶: ${this.formatTimeDifference(lastActive)}\n`;
      }
    }
    
    if (this.backgroundExecutions.has(connection.id)) {
      info += `ÂêéÂè∞‰ªªÂä°: Ê¥ªË∑É‰∏≠\n`;
    }
    
    return info;
  }
  
  /**
   * Ê†ºÂºèÂåñÊó∂Èó¥Â∑Æ
   */
  private formatTimeDifference(date: Date): string {
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    
    if (diffMs < 60000) {
      return 'ÂàöÂàöÊ¥ªË∑É';
    } else if (diffMs < 3600000) {
      const minutes = Math.floor(diffMs / 60000);
      return `${minutes}ÂàÜÈíüÂâçÊ¥ªË∑É`;
    } else if (diffMs < 86400000) {
      const hours = Math.floor(diffMs / 3600000);
      return `${hours}Â∞èÊó∂ÂâçÊ¥ªË∑É`;
    } else {
      const days = Math.floor(diffMs / 86400000);
      return `${days}Â§©ÂâçÊ¥ªË∑É`;
    }
  }
  
  /**
   * Ê†ºÂºèÂåñÊñá‰ª∂Â§ßÂ∞è
   */
  private formatFileSize(bytes: number): string {
    if (bytes < 1024) {
      return `${bytes} B`;
    } else if (bytes < 1024 * 1024) {
      return `${(bytes / 1024).toFixed(2)} KB`;
    } else if (bytes < 1024 * 1024 * 1024) {
      return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    } else {
      return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
    }
  }

  /**
   * ÂÅúÊ≠¢ÂêéÂè∞‰ªªÂä°ÊâßË°å
   */
  private stopBackgroundExecution(connectionId: string): void {
    const bgExec = this.backgroundExecutions.get(connectionId);
    if (bgExec) {
      clearInterval(bgExec.interval);
      this.backgroundExecutions.delete(connectionId);
    }
  }
  
  /**
   * Ê≥®ÂÜåËøûÊé•ÁÆ°ÁêÜÂ∑•ÂÖ∑
   */
  private registerConnectionTools(): void {
    // ÂàõÂª∫Êñ∞ËøûÊé•
    this.server.tool(
      "connect",
      {
        host: z.string(),
        port: z.number().optional(),
        username: z.string(),
        password: z.string().optional(),
        privateKey: z.string().optional(),
        passphrase: z.string().optional(),
        name: z.string().optional(),
        rememberPassword: z.boolean().optional(),
        tags: z.array(z.string()).optional()
      },
      async (params) => {
        try {
          // ÊûÑÂª∫ËøûÊé•ÈÖçÁΩÆ
          const config: SSHConnectionConfig = {
            host: params.host,
            port: params.port || parseInt(process.env.DEFAULT_SSH_PORT || '22'),
            username: params.username,
            password: params.password,
            keepaliveInterval: 60000,
            readyTimeout: parseInt(process.env.CONNECTION_TIMEOUT || '10000'),
            reconnect: true,
            reconnectTries: parseInt(process.env.RECONNECT_ATTEMPTS || '3'),
            reconnectDelay: 5000
          };
          
          // Â¶ÇÊûúÊèê‰æõ‰∫ÜÁßÅÈí•Ôºå‰ºòÂÖà‰ΩøÁî®ÁßÅÈí•ËÆ§ËØÅ
          if (params.privateKey) {
            config.privateKey = params.privateKey;
            config.passphrase = params.passphrase;
          }
          
          // ËøûÊé•Âà∞ÊúçÂä°Âô®
          const connection = await this.sshService.connect(
            config, 
            params.name, 
            params.rememberPassword || false,
            params.tags
          );
          
          // ËÆ∞ÂΩïÊ¥ªË∑ÉËøûÊé•
          this.activeConnections.set(connection.id, new Date());
          
          return {
            content: [{
              type: "text",
              text: `ËøûÊé•ÊàêÂäü!\n\n${this.formatConnectionInfo(connection)}`
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `ËøûÊé•Â§±Ë¥•: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // Êñ≠ÂºÄËøûÊé•
    this.server.tool(
      "disconnect",
      {
        connectionId: z.string()
      },
      async ({ connectionId }) => {
        try {
          const connection = this.sshService.getConnection(connectionId);
          if (!connection) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connectionId} ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          // Â¶ÇÊûúÊúâÂêéÂè∞‰ªªÂä°ÔºåÂÖàÂÅúÊ≠¢
          if (this.backgroundExecutions.has(connectionId)) {
            this.stopBackgroundExecution(connectionId);
          }
          
          const success = await this.sshService.disconnect(connectionId);
          
          // Âà†Èô§Ê¥ªË∑ÉËøûÊé•ËÆ∞ÂΩï
          this.activeConnections.delete(connectionId);
          
          if (success) {
            return {
              content: [{
                type: "text",
                text: `Â∑≤ÊàêÂäüÊñ≠ÂºÄËøûÊé• ${connection.name || connectionId}`
              }]
            };
          } else {
            return {
              content: [{
                type: "text",
                text: `Êñ≠ÂºÄËøûÊé•Â§±Ë¥•`
              }],
              isError: true
            };
          }
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Êñ≠ÂºÄËøûÊé•Êó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // Ëé∑ÂèñÊâÄÊúâËøûÊé•
    this.server.tool(
      "listConnections",
      {},
      async () => {
        try {
          const connections = await this.sshService.getAllConnections();
          
          if (connections.length === 0) {
            return {
              content: [{
                type: "text",
                text: "ÂΩìÂâçÊ≤°Êúâ‰øùÂ≠òÁöÑËøûÊé•"
              }]
            };
          }
          
          const formattedConnections = connections.map(conn => 
            this.formatConnectionInfo(conn)
          ).join("\n---\n");
          
          return {
            content: [{
              type: "text",
              text: `Â∑≤‰øùÂ≠òÁöÑËøûÊé•:\n\n${formattedConnections}`
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Ëé∑ÂèñËøûÊé•ÂàóË°®Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // Ëé∑ÂèñËøûÊé•ËØ¶ÊÉÖ
    this.server.tool(
      "getConnection",
      {
        connectionId: z.string()
      },
      ({ connectionId }) => {
        try {
          const connection = this.sshService.getConnection(connectionId);
          
          if (!connection) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connectionId} ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          return {
            content: [{
              type: "text",
              text: this.formatConnectionInfo(connection, true)
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Ëé∑ÂèñËøûÊé•ËØ¶ÊÉÖÂá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // Âà†Èô§ËøûÊé•
    this.server.tool(
      "deleteConnection",
      {
        connectionId: z.string()
      },
      async ({ connectionId }) => {
        try {
          const connection = this.sshService.getConnection(connectionId);
          
          if (!connection) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connectionId} ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          const name = connection.name || connectionId;
          
          // ÂÅúÊ≠¢ÂêéÂè∞‰ªªÂä°
          if (this.backgroundExecutions.has(connectionId)) {
            this.stopBackgroundExecution(connectionId);
          }
          
          // Âà†Èô§Ê¥ªË∑ÉËøûÊé•ËÆ∞ÂΩï
          this.activeConnections.delete(connectionId);
          
          const success = await this.sshService.deleteConnection(connectionId);
          
          if (success) {
            return {
              content: [{
                type: "text",
                text: `Â∑≤ÊàêÂäüÂà†Èô§ËøûÊé• "${name}"`
              }]
            };
          } else {
            return {
              content: [{
                type: "text",
                text: `Âà†Èô§ËøûÊé•Â§±Ë¥•`
              }],
              isError: true
            };
          }
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Âà†Èô§ËøûÊé•Êó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
  }
  
  /**
   * Ê≥®ÂÜåÂëΩ‰ª§ÊâßË°åÂ∑•ÂÖ∑
   */
  private registerCommandTools(): void {
    // ÊâßË°åÂëΩ‰ª§
    this.server.tool(
      "executeCommand",
      {
        connectionId: z.string(),
        command: z.string(),
        cwd: z.string().optional(),
        timeout: z.number().optional(),
        force: z.boolean().optional()
      },
      async ({ connectionId, command, cwd, timeout, force }) => {
        try {
          const connection = this.sshService.getConnection(connectionId);
          
          if (!connection) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connectionId} ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          if (connection.status !== ConnectionStatus.CONNECTED) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connection.name || connectionId} Êú™ËøûÊé•`
              }],
              isError: true
            };
          }
          
          // Êõ¥Êñ∞Ê¥ªË∑ÉÊó∂Èó¥
          this.activeConnections.set(connectionId, new Date());
          
          // Ëß£ÊûêtmuxÂëΩ‰ª§
          const tmuxSendKeysRegex = /tmux\s+send-keys\s+(?:-t\s+)?["']?([^"'\s]+)["']?\s+["']?(.+?)["']?\s+(?:Enter|C-m)/i;
          const tmuxCaptureRegex = /tmux\s+capture-pane\s+(?:-t\s+)["']?([^"'\s]+)["']?/i;
          const tmuxNewSessionRegex = /tmux\s+new-session\s+(?:-[ds]\s+)+(?:-s\s+)["']?([^"'\s]+)["']?/i;
          const tmuxKillSessionRegex = /tmux\s+kill-session\s+(?:-t\s+)["']?([^"'\s]+)["']?/i;
          const tmuxHasSessionRegex = /tmux\s+has-session\s+(?:-t\s+)["']?([^"'\s]+)["']?/i;
          
          // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÂú®ÊâßË°åÂâçÊçïËé∑tmux‰ºöËØùÂÜÖÂÆπÔºàÁî®‰∫éÊØîËæÉÂâçÂêéÂ∑ÆÂºÇÔºâ
          let beforeCapture: CommandResult | undefined;
          let sessionName: string | null = null;
          
          if (tmuxSendKeysRegex.test(command)) {
            const match = command.match(tmuxSendKeysRegex);
            if (match) {
              sessionName = match[1];
              
              // Â¶ÇÊûú‰∏çÊòØÂº∫Âà∂ÊâßË°å,ÊâçËøõË°åÈòªÂ°ûÊ£ÄÊµã
              if (!force) {
                try {
                  // ÊçïËé∑ÂΩìÂâç‰ºöËØùÂÜÖÂÆπ
                  const checkResult: CommandResult = await this.sshService.executeCommand(
                    connectionId,
                    `tmux list-panes -t ${sessionName} -F "#{pane_pid} #{pane_current_command}"`,
                    { cwd, timeout: 5000 }
                  );

                  if (checkResult?.stdout) {
                    const [panePid, currentCommand] = checkResult.stdout.trim().split(' ');
                    
                    if (panePid) {
                      // Ëé∑ÂèñËøõÁ®ãÁä∂ÊÄÅ
                      const processResult: CommandResult = await this.sshService.executeCommand(
                        connectionId,
                        `ps -o state= -p ${panePid}`,
                        { timeout: 3000 }
                      );

                      const processState = processResult?.stdout?.trim();
                      
                      // Ê£ÄÊü•ÊòØÂê¶Â§Ñ‰∫éÈòªÂ°ûÁä∂ÊÄÅ
                      const isBlocked = 
                        // ËøõÁ®ãÁä∂ÊÄÅÊ£ÄÊü•
                        processState === 'D' || // ‰∏çÂèØ‰∏≠Êñ≠ÁöÑÁù°Áú†Áä∂ÊÄÅ
                        processState === 'T' || // Â∑≤ÂÅúÊ≠¢
                        processState === 'W' || // ÂàÜÈ°µÁ≠âÂæÖ
                        
                        // Â∏∏ËßÅÁöÑ‰∫§‰∫íÂºèÁ®ãÂ∫è
                        /^(vim|nano|less|more|top|htop|man)$/.test(currentCommand) ||
                        
                        // Ê£ÄÊü•ÊòØÂê¶ÊúâÂ≠êËøõÁ®ãÂú®ËøêË°å
                        ((await this.sshService.executeCommand(
                          connectionId,
                          `pgrep -P ${panePid}`,
                          { timeout: 3000 }
                        ) as CommandResult)?.stdout || '').trim() !== '';

                      if (isBlocked) {
                        // Ëé∑ÂèñÊõ¥ËØ¶ÁªÜÁöÑËøõÁ®ã‰ø°ÊÅØ
                        const processInfo = await this.sshService.executeCommand(
                          connectionId,
                          `ps -o pid,ppid,stat,time,command -p ${panePid}`,
                          { timeout: 3000 }
                        );

                        // Ëé∑ÂèñÂëΩ‰ª§Ë°å‰∏ä‰∏ãÊñá
                        const contextOutput = await this.sshService.executeCommand(
                          connectionId,
                          `tmux capture-pane -p -t ${sessionName} -S -10`,
                          { timeout: 3000 }
                        );

                        return {
                          content: [{
                            type: "text",
                            text: `Ë≠¶Âëä: tmux‰ºöËØù "${sessionName}" ÂΩìÂâçÊúâÈòªÂ°ûËøõÁ®ã:\n\n` +
                                  `ÂΩìÂâç‰ºöËØù‰∏ä‰∏ãÊñá:\n${contextOutput.stdout}\n\n` +
                                  `ËøõÁ®ã‰ø°ÊÅØ:\n${processInfo.stdout}\n\n` +
                                  `Âª∫ËÆÆÊìç‰Ωú:\n` +
                                  `1. Â¶ÇÊûúÊòØ‰∫§‰∫íÂºèÁ®ãÂ∫è(vim/nanoÁ≠â), ËØ∑ÂÖàÊ≠£Â∏∏ÈÄÄÂá∫\n` +
                                  `2. Â¶ÇÊûúÊòØÂêéÂè∞‰ªªÂä°, ÂèØ‰ª•:\n` +
                                  `   - Á≠âÂæÖ‰ªªÂä°ÂÆåÊàêÔºàÊâßË°å sleep <seconds> ÂëΩ‰ª§ËøõË°åÁ≠âÂæÖÔºâ\n` +
                                  `   - ‰ΩøÁî® Ctrl+C (tmux send-keys -t ${sessionName} C-c)\n` +
                                  `   - ‰ΩøÁî® kill -TERM ${panePid} ÁªàÊ≠¢ËøõÁ®ã\n\n` +
                                  `‰∏∫ÈÅøÂÖçÂëΩ‰ª§ÂÜ≤Á™Å, Êú¨Ê¨°Êìç‰ΩúÂ∑≤ÂèñÊ∂à„ÄÇÂ¶ÇÊûúÁ°ÆÂÆöË¶ÅÂº∫Âà∂ÊâßË°å,ËØ∑Ê∑ªÂä† force: true ÂèÇÊï∞„ÄÇ`
                          }],
                          isError: true
                        };
                      }
                    }
                  }
                } catch (error) {
                  console.error('Ê£ÄÊü•tmux‰ºöËØùÁä∂ÊÄÅÊó∂Âá∫Èîô:', error);
                }
              }
            }
          }
          
          // Ê£ÄÊü•ÊòØÂê¶ÊòØtmuxÂëΩ‰ª§
          const isTmuxSendKeys = tmuxSendKeysRegex.test(command);
          const isTmuxCapture = tmuxCaptureRegex.test(command);
          const isTmuxNewSession = tmuxNewSessionRegex.test(command);
          const isTmuxKillSession = tmuxKillSessionRegex.test(command);
          const isTmuxHasSession = tmuxHasSessionRegex.test(command);
          const isTmuxCommand = isTmuxSendKeys || isTmuxCapture || isTmuxNewSession || isTmuxKillSession || isTmuxHasSession;
          
          // ÊâßË°åÂëΩ‰ª§
          const result = await this.sshService.executeCommand(connectionId, command, { cwd, timeout });
          
          // ÊûÑÂª∫ËæìÂá∫
          let output = '';
          
          if (result.stdout) {
            output += result.stdout;
          }
          
          if (result.stderr) {
            if (output) output += '\n';
            output += `ÈîôËØØËæìÂá∫:\n${result.stderr}`;
          }
          
          if (result.code !== 0) {
            output += `\nÂëΩ‰ª§ÈÄÄÂá∫Á†Å: ${result.code}`;
          }
          
          // Â¶ÇÊûúÊòØtmuxÂëΩ‰ª§‰∏îÂëΩ‰ª§ÊâßË°åÊàêÂäüÔºåÂ¢ûÂº∫ËæìÂá∫‰ø°ÊÅØ
          if (isTmuxCommand && result.code === 0 && (!output || output.trim() === '')) {
            try {
              // ËØÜÂà´ÂëΩ‰ª§Á±ªÂûãÂπ∂Â§ÑÁêÜ
              
              // ÂØπ‰∫é send-keys ÂëΩ‰ª§
              if (isTmuxSendKeys && sessionName && beforeCapture?.stdout) {
                // Á≠âÂæÖ‰∏ÄÊÆµÊó∂Èó¥ËÆ©ÂëΩ‰ª§ÊâßË°åÂÆåÊàê
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // ÊçïËé∑tmux‰ºöËØùÁöÑÂΩìÂâçÂÜÖÂÆπ
                const afterCapture = await this.sshService.executeCommand(
                  connectionId,
                  `tmux capture-pane -p -t ${sessionName}`,
                  { cwd, timeout: 5000 }
                );

                if (afterCapture?.stdout && beforeCapture?.stdout) {
                  // ÊØîËæÉÂâçÂêéÂ∑ÆÂºÇÔºåÊèêÂèñÊñ∞Â¢ûÂÜÖÂÆπ
                  const beforeLines = beforeCapture.stdout.trim().split('\n');
                  const afterLines = afterCapture.stdout.trim().split('\n');
                  
                  // ËÆ°ÁÆóÂá∫ÂÜÖÂÆπÂ∑ÆÂºÇ
                  let diffOutput = '';
                  
                  // ËÆ°ÁÆóÂÖ±ÂêåÂâçÁºÄÁöÑË°åÊï∞
                  let commonPrefix = 0;
                  
                  // ÊñπÊ≥ï1: ‰ªéÂêéÂæÄÂâçÊâæÂà∞Á¨¨‰∏Ä‰∏™‰∏çÂêåÁöÑË°å
                  if (beforeLines.length > 0 && afterLines.length > 0) {
                    // ÊâæÂà∞ÂÖ±ÂêåÂâçÁºÄÁöÑË°åÊï∞
                    while (commonPrefix < Math.min(beforeLines.length, afterLines.length) && 
                           beforeLines[commonPrefix] === afterLines[commonPrefix]) {
                      commonPrefix++;
                    }
                    
                    // ÊèêÂèñÊñ∞Â¢ûÁöÑË°å
                    const newLines = afterLines.slice(commonPrefix);
                    
                    if (newLines.length > 0) {
                      diffOutput = newLines.join('\n');
                    }
                    
                    // Â¶ÇÊûúÊèêÂèñÂ§±Ë¥•ÊàñÊ≤°ÊúâÂ∑ÆÂºÇÔºåÂ∞ùËØïÊñπÊ≥ï2
                    if (!diffOutput) {
                      // ÊñπÊ≥ï2: ÁÆÄÂçïÊØîËæÉÂâçÂêéÊñáÊú¨ÈïøÂ∫¶ÔºåÂ¶ÇÊûúÂèòÈïø‰∫ÜÔºåÂèñÂ¢ûÂä†ÁöÑÈÉ®ÂàÜ
                      if (afterCapture.stdout.length > beforeCapture.stdout.length) {
                        const commonStart = beforeCapture.stdout.length;
                        // ÊèêÂèñÂ¢ûÂä†ÁöÑÂÜÖÂÆπ
                        diffOutput = afterCapture.stdout.substring(commonStart);
                      }
                    }
                  }
                  
                  // Â¶ÇÊûúÊúâÂ∑ÆÂºÇËæìÂá∫Ôºå‰ΩøÁî®ÂÆÉÔºå‰ΩÜÊ∑ªÂä†Êõ¥Â§ö‰∏ä‰∏ãÊñá
                  if (diffOutput && diffOutput.trim()) {
                    // Ëé∑ÂèñÊõ¥Â§ö‰∏ä‰∏ãÊñáÔºöÊâæÂà∞Â∑ÆÂºÇÂºÄÂßãÁöÑ‰ΩçÁΩÆ
                    let contextOutput = '';
                    
                    // Âêë‰∏äÊâæ2-3‰∏™ÂëΩ‰ª§ÊèêÁ§∫Á¨¶Ê†áËÆ∞ÔºàÈÄöÂ∏∏ÊòØ$Êàñ#ÔºâÊù•Êèê‰æõ‰∏ä‰∏ãÊñá
                    const promptRegex = /^.*[\$#>]\s+/m;
                    let promptCount = 0;
                    let contextLines = [];
                    
                    // ÂÖà‰ªéÂéüÂßãËæìÂá∫ÁöÑ‰∏≠Èó¥ÈÉ®ÂàÜÂêë‰∏äÊêúÁ¥¢
                    const midPoint = Math.max(0, commonPrefix - 15);
                    for (let i = midPoint; i < afterLines.length; i++) {
                      contextLines.push(afterLines[i]);
                      // Â¶ÇÊûúÈÅáÂà∞ÂëΩ‰ª§ÊèêÁ§∫Á¨¶ÔºåËÆ°Êï∞Âä†1
                      if (promptRegex.test(afterLines[i])) {
                        promptCount++;
                      }
                      
                      // Â¶ÇÊûúÂ∑≤ÁªèÊâæÂà∞2‰∏™ÂëΩ‰ª§ÊèêÁ§∫Á¨¶ÊàñËÄÖÂ∑≤ÁªèËææÂà∞Â∑ÆÂºÇÈÉ®ÂàÜÔºåÂÅúÊ≠¢
                      if (promptCount >= 2 || i >= commonPrefix) {
                        break;
                      }
                    }
                    
                    // ÁÑ∂ÂêéÊ∑ªÂä†Â∑ÆÂºÇÈÉ®ÂàÜ
                    contextOutput = contextLines.join('\n');
                    if (contextOutput && !contextOutput.endsWith('\n')) {
                      contextOutput += '\n';
                    }
                    
                    // Ê∑ªÂä†Â∑ÆÂºÇËæìÂá∫
                    contextOutput += diffOutput.trim();
                    
                    output = `ÂëΩ‰ª§Â∑≤ÂèëÈÄÅÂà∞tmux‰ºöËØù "${sessionName}"ÔºåÂ∏¶‰∏ä‰∏ãÊñáÁöÑËæìÂá∫:\n\n${contextOutput}`;
                  } 
                  // Â¶ÇÊûúÊ≤°ÊâæÂà∞Â∑ÆÂºÇ‰ΩÜÂÜÖÂÆπÁ°ÆÂÆûÂèò‰∫ÜÔºåÊòæÁ§∫‰ºöËØùÊúÄÂêéÈÉ®ÂàÜÂÜÖÂÆπÔºàÂ∏¶‰∏ä‰∏ãÊñáÔºâ
                  else if (beforeCapture.stdout !== afterCapture.stdout) {
                    // Â∞ùËØïËé∑ÂèñÊúÄÂêéÂá†Ê¨°ÂëΩ‰ª§ÂíåËæìÂá∫
                    const lastLines = afterLines.slice(-30).join('\n');
                    
                    // ÂØªÊâæÂëΩ‰ª§ÊèêÁ§∫Á¨¶ÔºåÊèêÂèñÊúÄÂêéÂá†‰∏™ÂëΩ‰ª§
                    const promptPositions = [];
                    const promptRegex = /^.*[\$#>]\s+/m;
                    
                    // ÊâæÂá∫ÊâÄÊúâÂëΩ‰ª§ÊèêÁ§∫Á¨¶ÁöÑ‰ΩçÁΩÆ
                    for (let i = Math.max(0, afterLines.length - 30); i < afterLines.length; i++) {
                      if (promptRegex.test(afterLines[i])) {
                        promptPositions.push(i);
                      }
                    }
                    
                    // Â¶ÇÊûúÊâæÂà∞‰∫ÜËá≥Â∞ë‰∏Ä‰∏™ÂëΩ‰ª§ÊèêÁ§∫Á¨¶
                    if (promptPositions.length > 0) {
                      // ÂèñÊúÄÂêé3‰∏™ÂëΩ‰ª§ÔºàÂ¶ÇÊûúÊúâÁöÑËØùÔºâ
                      const startPosition = promptPositions.length > 3 
                        ? promptPositions[promptPositions.length - 3] 
                        : promptPositions[0];
                      
                      const contextOutput = afterLines.slice(startPosition).join('\n');
                      output = `ÂëΩ‰ª§Â∑≤ÂèëÈÄÅÂà∞tmux‰ºöËØù "${sessionName}"ÔºåÊúÄËøëÁöÑÂëΩ‰ª§ÂíåËæìÂá∫:\n\n${contextOutput}`;
                    } else {
                      // Â¶ÇÊûúÊ≤°ÊâæÂà∞ÂëΩ‰ª§ÊèêÁ§∫Á¨¶ÔºåÂ∞±‰ΩøÁî®ÊúÄÂêé20Ë°å
                      output = `ÂëΩ‰ª§Â∑≤ÂèëÈÄÅÂà∞tmux‰ºöËØù "${sessionName}"ÔºåÊúÄËøëÂÜÖÂÆπ:\n\n${lastLines}`;
                    }
                  }
                  // Ê≤°ÊúâÊòéÊòæÂèòÂåñ
                  else {
                    output = `ÂëΩ‰ª§Â∑≤ÂèëÈÄÅÂà∞tmux‰ºöËØù "${sessionName}"Ôºå‰ΩÜÊú™Ê£ÄÊµãÂà∞ËæìÂá∫ÂèòÂåñ`;
                  }
                }
              }
              // ÂØπ‰∫é new-session ÂëΩ‰ª§
              else if (isTmuxNewSession) {
                const match = command.match(tmuxNewSessionRegex);
                if (match) {
                  const sessionName = match[1];
                  output = `Â∑≤ÂàõÂª∫Êñ∞ÁöÑtmux‰ºöËØù "${sessionName}"`;
                  
                  // Ê£ÄÊü•‰ºöËØùÊòØÂê¶ÁúüÁöÑÂàõÂª∫ÊàêÂäü
                  const checkResult = await this.sshService.executeCommand(
                    connectionId,
                    `tmux has-session -t ${sessionName} 2>/dev/null && echo "‰ºöËØùÂ≠òÂú®" || echo "‰ºöËØùÂàõÂª∫Â§±Ë¥•"`,
                    { timeout: 3000 }
                  );
                  
                  if (checkResult.stdout && checkResult.stdout.includes("‰ºöËØùÂ≠òÂú®")) {
                    output += `\n‰ºöËØùÂ∑≤ÊàêÂäüÂêØÂä®Âπ∂Âú®ÂêéÂè∞ËøêË°å`;
                  }
                }
              }
              // ÂØπ‰∫é kill-session ÂëΩ‰ª§
              else if (isTmuxKillSession) {
                const match = command.match(tmuxKillSessionRegex);
                if (match) {
                  const sessionName = match[1];
                  output = `Â∑≤ÁªàÊ≠¢tmux‰ºöËØù "${sessionName}"`;
                }
              }
              // ÂØπ‰∫é has-session ÂëΩ‰ª§
              else if (isTmuxHasSession) {
                const match = command.match(tmuxHasSessionRegex);
                if (match) {
                  const sessionName = match[1];
                  if (result.code === 0) {
                    output = `tmux‰ºöËØù "${sessionName}" Â≠òÂú®`;
                  } else {
                    output = `tmux‰ºöËØù "${sessionName}" ‰∏çÂ≠òÂú®`;
                  }
                }
              }
              // ÂØπ‰∫é capture-pane ÂëΩ‰ª§
              else if (isTmuxCapture) {
                // Â¶ÇÊûúÁõ¥Êé•ÊòØcapture-paneÂëΩ‰ª§ÔºåËæìÂá∫Â∞±ÊòØÂÖ∂ÁªìÊûúÔºå‰∏çÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ
                if (!output || output.trim() === '') {
                  const match = command.match(tmuxCaptureRegex);
                  if (match) {
                    const sessionName = match[1];
                    output = `tmux‰ºöËØù "${sessionName}" ÂÜÖÂÆπÂ∑≤ÊçïËé∑Ôºå‰ΩÜÂéüÂßãÂëΩ‰ª§Êú™ËøîÂõûËæìÂá∫ÂÜÖÂÆπ`;
                  }
                }
              }
              // ÂØπ‰∫éÂ§çÂêàÂëΩ‰ª§ÔºàÂê´ÊúâÂ§ö‰∏™tmuxÂëΩ‰ª§Ôºâ
              else if (command.includes("tmux") && (command.includes("&&") || command.includes(";"))) {
                // Â∞ùËØïÊèêÂèñÊúÄÂêé‰∏Ä‰∏™tmuxÂëΩ‰ª§ÁöÑ‰ºöËØùÂêç
                const tmuxCommands = command.split(/&&|;/).map(cmd => cmd.trim());
                let lastSessionName = null;
                
                for (const cmd of tmuxCommands) {
                  let match;
                  if ((match = cmd.match(tmuxNewSessionRegex)) ||
                      (match = cmd.match(tmuxKillSessionRegex)) ||
                      (match = cmd.match(tmuxHasSessionRegex)) ||
                      (match = cmd.match(tmuxSendKeysRegex)) ||
                      (match = cmd.match(tmuxCaptureRegex))) {
                    lastSessionName = match[1];
                  }
                }
                
                if (lastSessionName) {
                  // Â¶ÇÊûúÊúÄÂêé‰∏Ä‰∏™ÂëΩ‰ª§ÊòØÂàõÂª∫‰ºöËØùÔºåÈÄöÁü•Áî®Êà∑‰ºöËØùÂ∑≤ÂàõÂª∫
                  if (tmuxCommands[tmuxCommands.length-1].includes("new-session")) {
                    output = `Â∑≤ÊâßË°åtmuxÂ§çÂêàÂëΩ‰ª§ÔºåÊúÄÂêéÂàõÂª∫‰∫Ü‰ºöËØù "${lastSessionName}"`;
                    
                    // Á≠âÂæÖ‰ºöËØùÂàõÂª∫ÂÆåÊàê
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Ê£ÄÊü•‰ºöËØùÊòØÂê¶ÁúüÁöÑÂàõÂª∫ÊàêÂäü
                    const checkResult = await this.sshService.executeCommand(
                      connectionId,
                      `tmux has-session -t ${lastSessionName} 2>/dev/null && echo "‰ºöËØùÂ≠òÂú®" || echo "‰ºöËØùÂàõÂª∫Â§±Ë¥•"`,
                      { timeout: 3000 }
                    );
                    
                    if (checkResult.stdout && checkResult.stdout.includes("‰ºöËØùÂ≠òÂú®")) {
                      output += `\n‰ºöËØùÂ∑≤ÊàêÂäüÂêØÂä®Âπ∂Âú®ÂêéÂè∞ËøêË°å`;
                    }
                  }
                  // Â¶ÇÊûúÊúÄÂêé‰∏Ä‰∏™ÂëΩ‰ª§ÊòØkill-sessionÔºåÈÄöÁü•Áî®Êà∑‰ºöËØùÂ∑≤ÁªàÊ≠¢
                  else if (tmuxCommands[tmuxCommands.length-1].includes("kill-session")) {
                    output = `Â∑≤ÊâßË°åtmuxÂ§çÂêàÂëΩ‰ª§ÔºåÊúÄÂêéÁªàÊ≠¢‰∫Ü‰ºöËØù "${lastSessionName}"`;
                  }
                  // ÂØπ‰∫éÂÖ∂‰ªñÂ§çÂêàÂëΩ‰ª§ÔºåÂ∞ùËØïÊçïËé∑ÊúÄÂêé‰∏Ä‰∏™‰ºöËØùÁöÑÂÜÖÂÆπ
                  else {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Á≠âÂæÖ‰ºöËØùÈòªÂ°ûÁä∂ÊÄÅËß£Èô§ÊàñË∂ÖÊó∂ÔºàÊúÄÂ§öÁ≠âÂæÖ10ÂàÜÈíüÔºâ
                    let isBlocked = true;
                    let waitStartTime = Date.now();
                    const maxWaitTime = 10 * 60 * 1000; // 10ÂàÜÈíü
                    
                    while (isBlocked && (Date.now() - waitStartTime < maxWaitTime)) {
                      try {
                        // Ê£ÄÊü•‰ºöËØùÊòØÂê¶Â§Ñ‰∫éÈòªÂ°ûÁä∂ÊÄÅ
                        const checkResult = await this.sshService.executeCommand(
                          connectionId,
                          `tmux list-panes -t ${lastSessionName} -F "#{pane_pid} #{pane_current_command}"`,
                          { cwd, timeout: 5000 }
                        );
                        
                        if (checkResult?.stdout) {
                          const [panePid, currentCommand] = checkResult.stdout.trim().split(' ');
                          
                          if (panePid) {
                            // Ëé∑ÂèñËøõÁ®ãÁä∂ÊÄÅ
                            const processResult = await this.sshService.executeCommand(
                              connectionId,
                              `ps -o state= -p ${panePid}`,
                              { timeout: 3000 }
                            );
                            
                            const processState = processResult?.stdout?.trim();
                            
                            // Ê£ÄÊü•ÊòØÂê¶Â§Ñ‰∫éÈòªÂ°ûÁä∂ÊÄÅ
                            isBlocked = 
                              // ËøõÁ®ãÁä∂ÊÄÅÊ£ÄÊü•
                              processState === 'D' || // ‰∏çÂèØ‰∏≠Êñ≠ÁöÑÁù°Áú†Áä∂ÊÄÅ
                              processState === 'T' || // Â∑≤ÂÅúÊ≠¢
                              processState === 'W' || // ÂàÜÈ°µÁ≠âÂæÖ
                              
                              // Â∏∏ËßÅÁöÑ‰∫§‰∫íÂºèÁ®ãÂ∫è
                              /^(vim|nano|less|more|top|htop|man)$/.test(currentCommand) ||
                              
                              // Ê£ÄÊü•ÊòØÂê¶ÊúâÂ≠êËøõÁ®ãÂú®ËøêË°å
                              ((await this.sshService.executeCommand(
                                connectionId,
                                `pgrep -P ${panePid}`,
                                { timeout: 3000 }
                              ))?.stdout || '').trim() !== '';
                            
                            if (!isBlocked) {
                              // ÈòªÂ°ûÂ∑≤Ëß£Èô§ÔºåÈÄÄÂá∫Âæ™ÁéØ
                              break;
                            }
                            
                            // Á≠âÂæÖ‰∏ÄÊÆµÊó∂Èó¥ÂÜçÊ£ÄÊü•
                            await new Promise(resolve => setTimeout(resolve, 5000));
                          } else {
                            // Ê≤°ÊúâÊúâÊïàÁöÑËøõÁ®ãIDÔºåËÆ§‰∏∫Ê≤°ÊúâÈòªÂ°û
                            isBlocked = false;
                          }
                        } else {
                          // Êó†Ê≥ïËé∑Âèñ‰ºöËØù‰ø°ÊÅØÔºåËÆ§‰∏∫Ê≤°ÊúâÈòªÂ°û
                          isBlocked = false;
                        }
                      } catch (error) {
                        console.error('Ê£ÄÊü•‰ºöËØùÈòªÂ°ûÁä∂ÊÄÅÊó∂Âá∫Èîô:', error);
                        // Âá∫ÈîôÊó∂ËÆ§‰∏∫Ê≤°ÊúâÈòªÂ°ûÔºåÈÅøÂÖçÊó†ÈôêÂæ™ÁéØ
                        isBlocked = false;
                      }
                    }
                    
                    // Ê£ÄÊü•ÊòØÂê¶ÊòØÂõ†‰∏∫Ë∂ÖÊó∂ËÄåÈÄÄÂá∫Âæ™ÁéØ
                    if (isBlocked && (Date.now() - waitStartTime >= maxWaitTime)) {
                      // Ëé∑ÂèñÂΩìÂâçÁä∂ÊÄÅ‰ø°ÊÅØ
                      try {
                        const processInfo = await this.sshService.executeCommand(
                          connectionId,
                          `tmux list-panes -t ${lastSessionName} -F "#{pane_pid}" | xargs ps -o pid,ppid,stat,time,command -p`,
                          { timeout: 5000 }
                        );
                        
                        const contextOutput = await this.sshService.executeCommand(
                          connectionId,
                          `tmux capture-pane -p -t ${lastSessionName} -S -10`,
                          { timeout: 3000 }
                        );
                        
                        output = `Â∑≤ÊâßË°åtmuxÂ§çÂêàÂëΩ‰ª§Ôºå‰ΩÜ‰ºöËØù "${lastSessionName}" ‰ªçÂ§Ñ‰∫éÈòªÂ°ûÁä∂ÊÄÅË∂ÖËøá10ÂàÜÈíü:\n\n` +
                                `ÂΩìÂâç‰ºöËØù‰∏ä‰∏ãÊñá:\n${contextOutput.stdout}\n\n` +
                                `ËøõÁ®ã‰ø°ÊÅØ:\n${processInfo.stdout}\n\n` +
                                `Â¶ÇÊûúÊòØÊ≠£Â∏∏ÊÉÖÂÜµÔºåËØ∑ÊâßË°å sleep <seconds> ÂëΩ‰ª§Á≠âÂæÖ`;
                      } catch (error) {
                        output = `Â∑≤ÊâßË°åtmuxÂ§çÂêàÂëΩ‰ª§Ôºå‰ΩÜ‰ºöËØù "${lastSessionName}" ‰ªçÂ§Ñ‰∫éÈòªÂ°ûÁä∂ÊÄÅË∂ÖËøá10ÂàÜÈíü„ÄÇÊó†Ê≥ïËé∑ÂèñËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ`;
                      }
                    } else {
                      // ÈòªÂ°ûÂ∑≤Ëß£Èô§Êàñ‰ºöËØù‰∏çÂ≠òÂú®ÔºåËé∑Âèñ‰ºöËØùÂÜÖÂÆπ
                      try {
                        const captureResult = await this.sshService.executeCommand(
                          connectionId,
                          `tmux has-session -t ${lastSessionName} 2>/dev/null && tmux capture-pane -p -t ${lastSessionName} || echo "‰ºöËØù‰∏çÂ≠òÂú®"`,
                          { cwd, timeout: 5000 }
                        );
                        
                        if (captureResult.stdout && !captureResult.stdout.includes("‰ºöËØù‰∏çÂ≠òÂú®")) {
                          // ÊèêÂèñÊúÄÂêé40Ë°å
                          const lines = captureResult.stdout.split('\n');
                          const lastLines = lines.slice(-40).join('\n');
                          
                          output = `Â∑≤ÊâßË°åtmuxÂ§çÂêàÂëΩ‰ª§Ôºå‰ºöËØù "${lastSessionName}" ÂΩìÂâçÂÜÖÂÆπ:\n\n${lastLines}`;
                        } else {
                          output = `Â∑≤ÊâßË°åtmuxÂ§çÂêàÂëΩ‰ª§Ôºå‰ΩÜ‰ºöËØù "${lastSessionName}" ‰∏çÂ≠òÂú®ÊàñÊó†Ê≥ïÊçïËé∑ÂÜÖÂÆπ`;
                        }
                      } catch (err) {
                        output = `Â∑≤ÊâßË°åtmuxÂ§çÂêàÂëΩ‰ª§ÔºåÊ∂âÂèä‰ºöËØù "${lastSessionName}"`;
                      }
                    }
                  }
                } else {
                  output = "Â∑≤ÊâßË°åtmuxÂ§çÂêàÂëΩ‰ª§";
                }
              }
            } catch (captureError) {
              console.error('Â§ÑÁêÜtmuxÂëΩ‰ª§ËæìÂá∫Êó∂Âá∫Èîô:', captureError);
              // Â¶ÇÊûúÊçïËé∑Â§±Ë¥•Ôºå‰ΩøÁî®ÂéüÂßãËæìÂá∫
              output = `tmuxÂëΩ‰ª§Â∑≤ÊâßË°åÔºå‰ΩÜÊó†Ê≥ïËé∑ÂèñÈ¢ùÂ§ñ‰ø°ÊÅØ: ${captureError instanceof Error ? captureError.message : String(captureError)}`;
            }
          }
          
          // Â§ÑÁêÜËæìÂá∫ÈïøÂ∫¶ÈôêÂà∂
          output = this.limitOutputLength(output);
          
          return {
            content: [{
              type: "text",
              text: output || 'ÂëΩ‰ª§ÊâßË°åÊàêÂäüÔºåÊó†ËæìÂá∫'
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `ÊâßË°åÂëΩ‰ª§Êó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // ÂêéÂè∞ÊâßË°åÂëΩ‰ª§
    this.server.tool(
      "backgroundExecute",
      {
        connectionId: z.string(),
        command: z.string(),
        interval: z.number().optional(),
        cwd: z.string().optional()
      },
      async ({ connectionId, command, interval = 10000, cwd }) => {
        try {
          const connection = this.sshService.getConnection(connectionId);
          
          if (!connection) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connectionId} ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          if (connection.status !== ConnectionStatus.CONNECTED) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connection.name || connectionId} Êú™ËøûÊé•`
              }],
              isError: true
            };
          }
          
          // Â¶ÇÊûúÂ∑≤Â≠òÂú®ÂêéÂè∞‰ªªÂä°ÔºåÂÖàÂÅúÊ≠¢
          if (this.backgroundExecutions.has(connectionId)) {
            this.stopBackgroundExecution(connectionId);
          }
          
          // Êõ¥Êñ∞Ê¥ªË∑ÉÊó∂Èó¥
          this.activeConnections.set(connectionId, new Date());
          
          // ÂÖàÊâßË°å‰∏ÄÊ¨°ÂëΩ‰ª§
          await this.sshService.executeCommand(connectionId, command, { cwd });
          
          // ËÆæÁΩÆÂÆöÊó∂Âô®
          const timer = setInterval(async () => {
            try {
              const conn = this.sshService.getConnection(connectionId);
              if (conn && conn.status === ConnectionStatus.CONNECTED) {
                await this.sshService.executeCommand(connectionId, command, { cwd });
                
                // Êõ¥Êñ∞ÊúÄÂêéÊ£ÄÊü•Êó∂Èó¥
                const bgExec = this.backgroundExecutions.get(connectionId);
                if (bgExec) {
                  bgExec.lastCheck = new Date();
                }
              } else {
                // Â¶ÇÊûúËøûÊé•Â∑≤‰∏çÂèØÁî®ÔºåÂÅúÊ≠¢ÂêéÂè∞‰ªªÂä°
                this.stopBackgroundExecution(connectionId);
              }
            } catch (error) {
              console.error(`ÂêéÂè∞ÊâßË°åÂëΩ‰ª§Âá∫Èîô:`, error);
              // ‰∏çÂÅúÊ≠¢‰ªªÂä°ÔºåÁªßÁª≠‰∏ã‰∏ÄÊ¨°Â∞ùËØï
            }
          }, interval);
          
          // ËÆ∞ÂΩïÂêéÂè∞‰ªªÂä°
          this.backgroundExecutions.set(connectionId, {
            interval: timer,
            lastCheck: new Date()
          });
          
          return {
            content: [{
              type: "text",
              text: `Â∑≤Âú®ÂêéÂè∞ÂêØÂä®ÂëΩ‰ª§: ${command}\nÈó¥Èöî: ${interval / 1000}Áßí\nËøûÊé•: ${connection.name || connectionId}\n\n‰ΩøÁî® stopBackground Â∑•ÂÖ∑ÂèØÂÅúÊ≠¢Ê≠§ÂêéÂè∞‰ªªÂä°„ÄÇ`
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `ËÆæÁΩÆÂêéÂè∞‰ªªÂä°Êó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // ÂÅúÊ≠¢ÂêéÂè∞ÊâßË°å
    this.server.tool(
      "stopBackground",
      {
        connectionId: z.string()
      },
      ({ connectionId }) => {
        try {
          const connection = this.sshService.getConnection(connectionId);
          
          if (!connection) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connectionId} ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          if (!this.backgroundExecutions.has(connectionId)) {
            return {
              content: [{
                type: "text",
                text: `ËøûÊé• ${connection.name || connectionId} Ê≤°ÊúâÊ≠£Âú®ËøêË°åÁöÑÂêéÂè∞‰ªªÂä°`
              }]
            };
          }
          
          // ÂÅúÊ≠¢ÂêéÂè∞‰ªªÂä°
          this.stopBackgroundExecution(connectionId);
          
          return {
            content: [{
              type: "text",
              text: `Â∑≤ÂÅúÊ≠¢ËøûÊé• ${connection.name || connectionId} ÁöÑÂêéÂè∞‰ªªÂä°`
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `ÂÅúÊ≠¢ÂêéÂè∞‰ªªÂä°Êó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // Ëé∑ÂèñÂΩìÂâçÁõÆÂΩïÂ∑•ÂÖ∑
    this.server.tool(
      "getCurrentDirectory",
      {
        connectionId: z.string()
      },
      async ({ connectionId }) => {
        try {
          const connection = this.sshService.getConnection(connectionId);
          
          if (!connection) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connectionId} ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          if (connection.status !== ConnectionStatus.CONNECTED) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connection.name || connectionId} Êú™ËøûÊé•`
              }],
              isError: true
            };
          }
          
          // Êõ¥Êñ∞Ê¥ªË∑ÉÊó∂Èó¥
          this.activeConnections.set(connectionId, new Date());
          
          // Ëé∑ÂèñÂΩìÂâçÁõÆÂΩï
          const result = await this.sshService.executeCommand(connectionId, 'pwd');
          
          return {
            content: [{
              type: "text",
              text: result.stdout.trim()
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Ëé∑ÂèñÂΩìÂâçÁõÆÂΩïÊó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
  }
  
  /**
   * Ê≥®ÂÜåÊñá‰ª∂‰º†ËæìÂ∑•ÂÖ∑
   */
  private registerFileTools(): void {
    // ‰∏ä‰º†Êñá‰ª∂
    this.server.tool(
      "uploadFile",
      {
        connectionId: z.string(),
        localPath: z.string(),
        remotePath: z.string()
      },
      async ({ connectionId, localPath, remotePath }) => {
        try {
          const connection = this.sshService.getConnection(connectionId);
          
          if (!connection) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connectionId} ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          if (connection.status !== ConnectionStatus.CONNECTED) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connection.name || connectionId} Êú™ËøûÊé•`
              }],
              isError: true
            };
          }
          
          // Ê£ÄÊü•Êú¨Âú∞Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
          if (!fs.existsSync(localPath)) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: Êú¨Âú∞Êñá‰ª∂ "${localPath}" ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          // Êõ¥Êñ∞Ê¥ªË∑ÉÊó∂Èó¥
          this.activeConnections.set(connectionId, new Date());
          
          // ‰∏ä‰º†Êñá‰ª∂Âπ∂Ëé∑Âèñ‰º†ËæìID
          const transferInfo = await this.sshService.uploadFile(connectionId, localPath, remotePath);
          const transferId = transferInfo.id;
          
          // ÁõëÂê¨‰º†ËæìËøõÂ∫¶
          const unsubscribe = this.sshService.onTransferProgress((info: FileTransferInfo) => {
            // Âè™Âú®ËøõÂ∫¶ÂèòÂåñÂ§ß‰∫é5%Êó∂ÂèëÈÄÅÊõ¥Êñ∞ÔºåÈÅøÂÖçËøáÂ§ö‰∫ã‰ª∂
            if (info.progress % 5 === 0 || info.status === 'completed' || info.status === 'failed') {
              (this.server as any).sendEvent('file_transfer_progress', {
                transferId: info.id,
                progress: Math.round(info.progress),
                status: info.status,
                human: `Êñá‰ª∂‰º†Ëæì ${info.id} - ${info.status}: ${Math.round(info.progress)}% (${this.formatFileSize(info.bytesTransferred)}/${this.formatFileSize(info.size)})`
              });
            }
          });
          
          try {
            // Ëé∑ÂèñÊúÄÁªàÁªìÊûú
            const result = this.sshService.getTransferInfo(transferId);
            
            if (result && result.status === 'failed') {
              return {
                content: [{
                  type: "text",
                  text: `Êñá‰ª∂‰∏ä‰º†Â§±Ë¥•: ${result.error || 'Êú™Áü•ÈîôËØØ'}`
                }],
                isError: true,
                transferId
              };
            }
            
            const fileName = path.basename(localPath);
            
            return {
              content: [{
                type: "text",
                text: `Êñá‰ª∂ "${fileName}" ‰∏ä‰º†ÊàêÂäü\nÊú¨Âú∞Ë∑ØÂæÑ: ${localPath}\nËøúÁ®ãË∑ØÂæÑ: ${remotePath}`
              }],
              transferId
            };
          } finally {
            // Á°Æ‰øùÂßãÁªàÂèñÊ∂àËÆ¢ÈòÖ
            unsubscribe();
          }
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `‰∏ä‰º†Êñá‰ª∂Êó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // ‰∏ãËΩΩÊñá‰ª∂
    this.server.tool(
      "downloadFile",
      {
        connectionId: z.string(),
        remotePath: z.string(),
        localPath: z.string().optional()
      },
      async ({ connectionId, remotePath, localPath }) => {
        try {
          const connection = this.sshService.getConnection(connectionId);
          
          if (!connection) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connectionId} ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          if (connection.status !== ConnectionStatus.CONNECTED) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connection.name || connectionId} Êú™ËøûÊé•`
              }],
              isError: true
            };
          }
          
          // Á°ÆÂÆöÊú¨Âú∞‰øùÂ≠òË∑ØÂæÑ
          let savePath = localPath;
          if (!savePath) {
            const fileName = path.basename(remotePath);
            savePath = path.join(os.homedir(), 'Downloads', fileName);
            
            // Á°Æ‰øùÁõÆÂΩïÂ≠òÂú®
            const saveDir = path.dirname(savePath);
            if (!fs.existsSync(saveDir)) {
              fs.mkdirSync(saveDir, { recursive: true });
            }
          }
          
          // Êõ¥Êñ∞Ê¥ªË∑ÉÊó∂Èó¥
          this.activeConnections.set(connectionId, new Date());
          
          // ‰∏ãËΩΩÊñá‰ª∂Âπ∂Ëé∑Âèñ‰º†ËæìID
          const transferInfo = await this.sshService.downloadFile(connectionId, remotePath, savePath);
          const transferId = transferInfo.id;
          
          // ÁõëÂê¨‰º†ËæìËøõÂ∫¶
          const unsubscribe = this.sshService.onTransferProgress((info: FileTransferInfo) => {
            // Âè™Âú®ËøõÂ∫¶ÂèòÂåñÂ§ß‰∫é5%Êó∂ÂèëÈÄÅÊõ¥Êñ∞ÔºåÈÅøÂÖçËøáÂ§ö‰∫ã‰ª∂
            if (info.progress % 5 === 0 || info.status === 'completed' || info.status === 'failed') {
              (this.server as any).sendEvent('file_transfer_progress', {
                transferId: info.id,
                progress: Math.round(info.progress),
                status: info.status,
                human: `Êñá‰ª∂‰º†Ëæì ${info.id} - ${info.status}: ${Math.round(info.progress)}% (${this.formatFileSize(info.bytesTransferred)}/${this.formatFileSize(info.size)})`
              });
            }
          });
          
          try {
            // Ëé∑ÂèñÊúÄÁªàÁªìÊûú
            const result = this.sshService.getTransferInfo(transferId);
            
            if (result && result.status === 'failed') {
              return {
                content: [{
                  type: "text",
                  text: `Êñá‰ª∂‰∏ãËΩΩÂ§±Ë¥•: ${result.error || 'Êú™Áü•ÈîôËØØ'}`
                }],
                isError: true,
                transferId
              };
            }
            
            const fileName = path.basename(remotePath);
            
            return {
              content: [{
                type: "text",
                text: `Êñá‰ª∂ "${fileName}" ‰∏ãËΩΩÊàêÂäü\nËøúÁ®ãË∑ØÂæÑ: ${remotePath}\nÊú¨Âú∞Ë∑ØÂæÑ: ${savePath}`
              }],
              transferId
            };
          } finally {
            // Á°Æ‰øùÂßãÁªàÂèñÊ∂àËÆ¢ÈòÖ
            unsubscribe();
          }
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `‰∏ãËΩΩÊñá‰ª∂Êó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // ÊâπÈáè‰∏ä‰º†Êñá‰ª∂
    this.server.tool(
      "batchUploadFiles",
      {
        connectionId: z.string(),
        files: z.array(z.object({
          localPath: z.string(),
          remotePath: z.string()
        }))
      },
      async ({ connectionId, files }) => {
        try {
          const connection = this.sshService.getConnection(connectionId);
          
          if (!connection) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connectionId} ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          if (connection.status !== ConnectionStatus.CONNECTED) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connection.name || connectionId} Êú™ËøûÊé•`
              }],
              isError: true
            };
          }
          
          // Ê£ÄÊü•ÊâÄÊúâÊú¨Âú∞Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
          const missingFiles = files.filter(file => !fs.existsSync(file.localPath));
          if (missingFiles.length > 0) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ‰ª•‰∏ãÊú¨Âú∞Êñá‰ª∂‰∏çÂ≠òÂú®:\n${missingFiles.map(f => f.localPath).join('\n')}`
              }],
              isError: true
            };
          }
          
          // Êõ¥Êñ∞Ê¥ªË∑ÉÊó∂Èó¥
          this.activeConnections.set(connectionId, new Date());
          
          // ÊâπÈáè‰º†ËæìÊñá‰ª∂
          const transferIds = await this.sshService.batchTransfer({
            connectionId,
            items: files,
            direction: 'upload'
          });
          
          if (transferIds.length === 0) {
            return {
              content: [{
                type: "text",
                text: `Ê≤°ÊúâÊñá‰ª∂Ë¢´‰∏ä‰º†`
              }],
              isError: true
            };
          }
          
          // Ëé∑Âèñ‰º†Ëæì‰ø°ÊÅØ
          const transferInfos = transferIds.map(id => this.sshService.getTransferInfo(id)).filter(Boolean) as FileTransferInfo[];
          
          // ËÆæÁΩÆÊâπÈáè‰º†ËæìËøõÂ∫¶ÁõëÂê¨
          const listeners: (() => void)[] = [];
          
          for (const transferId of transferIds) {
            const unsubscribe = this.sshService.onTransferProgress((info: FileTransferInfo) => {
              if (info.id === transferId && (info.progress % 10 === 0 || info.status === 'completed' || info.status === 'failed')) {
                (this.server as any).sendEvent('batch_transfer_progress', {
                  transferId: info.id,
                  progress: Math.round(info.progress),
                  status: info.status,
                  direction: 'upload',
                  human: `ÊâπÈáè‰∏ä‰º† - Êñá‰ª∂: ${path.basename(info.localPath)} - ${info.status}: ${Math.round(info.progress)}%`
                });
              }
            });
            
            listeners.push(unsubscribe);
          }
          
          try {
            // Á≠âÂæÖÊâÄÊúâ‰º†ËæìÂÆåÊàê
            await new Promise<void>((resolve) => {
              const checkInterval = setInterval(() => {
                const allDone = transferIds.every(id => {
                  const info = this.sshService.getTransferInfo(id);
                  return info && (info.status === 'completed' || info.status === 'failed');
                });
                
                if (allDone) {
                  clearInterval(checkInterval);
                  resolve();
                }
              }, 500);
            });
            
            // ËÆ°ÁÆóÊàêÂäüÂíåÂ§±Ë¥•ÁöÑÊï∞Èáè
            const successCount = transferInfos.filter(info => info.status === 'completed').length;
            const failedCount = transferInfos.filter(info => info.status === 'failed').length;
            
            return {
              content: [{
                type: "text",
                text: `ÊâπÈáè‰∏ä‰º†ÂÆåÊàê\nÊàêÂäü: ${successCount}‰∏™Êñá‰ª∂\nÂ§±Ë¥•: ${failedCount}‰∏™Êñá‰ª∂`
              }],
              transferIds
            };
          } finally {
            // Ê∏ÖÁêÜÊâÄÊúâÁõëÂê¨Âô®
            listeners.forEach(unsubscribe => unsubscribe());
          }
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `ÊâπÈáè‰∏ä‰º†Êñá‰ª∂Êó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // ÊâπÈáè‰∏ãËΩΩÊñá‰ª∂
    this.server.tool(
      "batchDownloadFiles",
      {
        connectionId: z.string(),
        files: z.array(z.object({
          remotePath: z.string(),
          localPath: z.string().optional()
        }))
      },
      async ({ connectionId, files }) => {
        try {
          const connection = this.sshService.getConnection(connectionId);
          
          if (!connection) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connectionId} ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          if (connection.status !== ConnectionStatus.CONNECTED) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connection.name || connectionId} Êú™ËøûÊé•`
              }],
              isError: true
            };
          }
          
          // Â§ÑÁêÜÊú¨Âú∞Ë∑ØÂæÑ
          const normalizedFiles = files.map(file => {
            if (!file.remotePath) {
              return null; // Ë∑≥ËøáÊó†ÊïàÈ°π
            }
            
            // Â¶ÇÊûúÊ≤°ÊúâÊèê‰æõÊú¨Âú∞Ë∑ØÂæÑÔºåÁîüÊàê‰∏Ä‰∏™ÈªòËÆ§Ë∑ØÂæÑ
            if (!file.localPath) {
              const fileName = path.basename(file.remotePath);
              const localPath = path.join(os.homedir(), 'Downloads', fileName);
              
              // Á°Æ‰øùÁõÆÂΩïÂ≠òÂú®
              const saveDir = path.dirname(localPath);
              if (!fs.existsSync(saveDir)) {
                fs.mkdirSync(saveDir, { recursive: true });
              }
              
              return { remotePath: file.remotePath, localPath };
            }
            return file;
          }).filter(item => item !== null) as { remotePath: string, localPath: string }[];
          
          if (normalizedFiles.length === 0) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: Ê≤°ÊúâÊúâÊïàÁöÑÊñá‰ª∂‰º†ËæìÈ°π`
              }],
              isError: true
            };
          }
          
          // Êõ¥Êñ∞Ê¥ªË∑ÉÊó∂Èó¥
          this.activeConnections.set(connectionId, new Date());
          
          // ÂºÄÂßãÊâπÈáè‰∏ãËΩΩ
          const transferIds = await this.sshService.batchTransfer({
            connectionId,
            items: normalizedFiles,
            direction: 'download'
          });
          
          if (transferIds.length === 0) {
            return {
              content: [{
                type: "text",
                text: `Ê≤°ÊúâÊñá‰ª∂Ë¢´‰∏ãËΩΩ`
              }],
              isError: true
            };
          }
          
          // Ëé∑Âèñ‰º†Ëæì‰ø°ÊÅØ
          const transferInfos = transferIds.map(id => this.sshService.getTransferInfo(id)).filter(Boolean) as FileTransferInfo[];
          
          // ËÆæÁΩÆÊâπÈáè‰º†ËæìËøõÂ∫¶ÁõëÂê¨
          const listeners: (() => void)[] = [];
          
          for (const transferId of transferIds) {
            const unsubscribe = this.sshService.onTransferProgress((info: FileTransferInfo) => {
              if (info.id === transferId && (info.progress % 10 === 0 || info.status === 'completed' || info.status === 'failed')) {
                (this.server as any).sendEvent('batch_transfer_progress', {
                  transferId: info.id,
                  progress: Math.round(info.progress),
                  status: info.status,
                  direction: 'download',
                  human: `ÊâπÈáè‰∏ãËΩΩ - Êñá‰ª∂: ${path.basename(info.remotePath)} - ${info.status}: ${Math.round(info.progress)}%`
                });
              }
            });
            
            listeners.push(unsubscribe);
          }
          
          try {
            // Á≠âÂæÖÊâÄÊúâ‰º†ËæìÂÆåÊàê
            await new Promise<void>((resolve) => {
              const checkInterval = setInterval(() => {
                const allDone = transferIds.every(id => {
                  const info = this.sshService.getTransferInfo(id);
                  return info && (info.status === 'completed' || info.status === 'failed');
                });
                
                if (allDone) {
                  clearInterval(checkInterval);
                  resolve();
                }
              }, 500);
            });
            
            // ËÆ°ÁÆóÊàêÂäüÂíåÂ§±Ë¥•ÁöÑÊï∞Èáè
            const successCount = transferInfos.filter(info => info.status === 'completed').length;
            const failedCount = transferInfos.filter(info => info.status === 'failed').length;
            
            return {
              content: [{
                type: "text",
                text: `ÊâπÈáè‰∏ãËΩΩÂÆåÊàê\nÊàêÂäü: ${successCount}‰∏™Êñá‰ª∂\nÂ§±Ë¥•: ${failedCount}‰∏™Êñá‰ª∂`
              }],
              transferIds
            };
          } finally {
            // Ê∏ÖÁêÜÊâÄÊúâÁõëÂê¨Âô®
            listeners.forEach(unsubscribe => unsubscribe());
          }
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `ÊâπÈáè‰∏ãËΩΩÊñá‰ª∂Êó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // Ëé∑ÂèñÊñá‰ª∂‰º†ËæìÁä∂ÊÄÅ
    this.server.tool(
      "getFileTransferStatus",
      {
        transferId: z.string()
      },
      async ({ transferId }) => {
        try {
          const transfer = this.sshService.getTransferInfo(transferId);
          
          if (!transfer) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ‰º†Ëæì ${transferId} ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          let statusText;
          switch (transfer.status) {
            case 'pending':
              statusText = 'Á≠âÂæÖ‰∏≠';
              break;
            case 'in-progress':
              statusText = '‰º†Ëæì‰∏≠';
              break;
            case 'completed':
              statusText = 'Â∑≤ÂÆåÊàê';
              break;
            case 'failed':
              statusText = 'Â§±Ë¥•';
              break;
            default:
              statusText = transfer.status;
          }
          
          const directionText = transfer.direction === 'upload' ? '‰∏ä‰º†' : '‰∏ãËΩΩ';
          const fileName = transfer.direction === 'upload' 
            ? path.basename(transfer.localPath)
            : path.basename(transfer.remotePath);
          
          let output = `Êñá‰ª∂ ${directionText} Áä∂ÊÄÅ:\n`;
          output += `ID: ${transfer.id}\n`;
          output += `Êñá‰ª∂Âêç: ${fileName}\n`;
          output += `Áä∂ÊÄÅ: ${statusText}\n`;
          output += `ËøõÂ∫¶: ${Math.round(transfer.progress)}%\n`;
          output += `Â§ßÂ∞è: ${this.formatFileSize(transfer.size)}\n`;
          output += `Â∑≤‰º†Ëæì: ${this.formatFileSize(transfer.bytesTransferred)}\n`;
          
          if (transfer.startTime) {
            output += `ÂºÄÂßãÊó∂Èó¥: ${transfer.startTime.toLocaleString()}\n`;
          }
          
          if (transfer.endTime) {
            output += `ÁªìÊùüÊó∂Èó¥: ${transfer.endTime.toLocaleString()}\n`;
            
            // ËÆ°ÁÆó‰º†ËæìÈÄüÂ∫¶
            const duration = (transfer.endTime.getTime() - transfer.startTime.getTime()) / 1000;
            if (duration > 0) {
              const speed = transfer.bytesTransferred / duration;
              output += `Âπ≥ÂùáÈÄüÂ∫¶: ${this.formatFileSize(speed)}/s\n`;
            }
          }
          
          if (transfer.error) {
            output += `ÈîôËØØ: ${transfer.error}\n`;
          }
          
          return {
            content: [{
              type: "text",
              text: output
            }],
            transfer
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Ëé∑ÂèñÊñá‰ª∂‰º†ËæìÁä∂ÊÄÅÊó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // ÂàóÂá∫ÊâÄÊúâÊñá‰ª∂‰º†Ëæì
    this.server.tool(
      "listFileTransfers",
      {},
      async () => {
        try {
          const transfers = this.sshService.getAllTransfers();
          
          if (transfers.length === 0) {
            return {
              content: [{
                type: "text",
                text: "Ê≤°ÊúâÊñá‰ª∂‰º†ËæìËÆ∞ÂΩï"
              }]
            };
          }
          
          let output = `Êñá‰ª∂‰º†ËæìËÆ∞ÂΩï (${transfers.length}):\n\n`;
          
          for (const transfer of transfers) {
            const fileName = transfer.direction === 'upload' 
              ? path.basename(transfer.localPath)
              : path.basename(transfer.remotePath);
            
            let status;
            switch (transfer.status) {
              case 'pending':
                status = '‚è≥ Á≠âÂæÖ‰∏≠';
                break;
              case 'in-progress':
                status = 'üîÑ ‰º†Ëæì‰∏≠';
                break;
              case 'completed':
                status = '‚úÖ Â∑≤ÂÆåÊàê';
                break;
              case 'failed':
                status = '‚ùå Â§±Ë¥•';
                break;
              default:
                status = transfer.status;
            }
            
            output += `${status} ${transfer.direction === 'upload' ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è'} ${fileName}\n`;
            output += `ID: ${transfer.id}\n`;
            output += `ËøõÂ∫¶: ${Math.round(transfer.progress)}% (${this.formatFileSize(transfer.bytesTransferred)}/${this.formatFileSize(transfer.size)})\n`;
            
            if (transfer.startTime) {
              output += `ÂºÄÂßã: ${transfer.startTime.toLocaleString()}\n`;
            }
            
            if (transfer.endTime) {
              output += `ÁªìÊùü: ${transfer.endTime.toLocaleString()}\n`;
            }
            
            if (transfer.error) {
              output += `ÈîôËØØ: ${transfer.error}\n`;
            }
            
            output += '\n';
          }
          
          return {
            content: [{
              type: "text",
              text: output
            }],
            transfers
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Ëé∑ÂèñÊñá‰ª∂‰º†ËæìÂàóË°®Êó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
  }
  
  /**
   * Ê≥®ÂÜå‰ºöËØùÁÆ°ÁêÜÂ∑•ÂÖ∑
   */
  private registerSessionTools(): void {
    // ÂàóÂá∫Ê¥ªË∑É‰ºöËØù
    this.server.tool(
      "listActiveSessions",
      {},
      async () => {
        try {
          if (this.activeConnections.size === 0) {
            return {
              content: [{
                type: "text",
                text: "ÂΩìÂâçÊ≤°ÊúâÊ¥ªË∑ÉÁöÑ‰ºöËØù"
              }]
            };
          }
          
          let output = "Ê¥ªË∑É‰ºöËØù:\n\n";
          
          for (const [id, lastActive] of this.activeConnections.entries()) {
            const connection = this.sshService.getConnection(id);
            if (connection) {
              output += this.formatConnectionInfo(connection);
              output += `‰∏äÊ¨°Ê¥ªÂä®: ${this.formatTimeDifference(lastActive)}\n`;
              
              if (this.backgroundExecutions.has(id)) {
                const bgExec = this.backgroundExecutions.get(id);
                if (bgExec) {
                  output += `ÂêéÂè∞‰ªªÂä°: Ê¥ªË∑É‰∏≠ÔºåÊúÄÂêéÊâßË°å: ${this.formatTimeDifference(bgExec.lastCheck)}\n`;
                }
              }
              
              output += "\n---\n\n";
            }
          }
          
          return {
            content: [{
              type: "text",
              text: output
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Ëé∑ÂèñÊ¥ªË∑É‰ºöËØùÊó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // ÂàóÂá∫ÂêéÂè∞‰ªªÂä°
    this.server.tool(
      "listBackgroundTasks",
      {},
      () => {
        try {
          if (this.backgroundExecutions.size === 0) {
            return {
              content: [{
                type: "text",
                text: "ÂΩìÂâçÊ≤°ÊúâËøêË°å‰∏≠ÁöÑÂêéÂè∞‰ªªÂä°"
              }]
            };
          }
          
          let output = "ËøêË°å‰∏≠ÁöÑÂêéÂè∞‰ªªÂä°:\n\n";
          
          for (const [id, info] of this.backgroundExecutions.entries()) {
            const connection = this.sshService.getConnection(id);
            if (connection) {
              output += `ËøûÊé•: ${connection.name || connection.id}\n`;
              output += `‰∏ªÊú∫: ${connection.config.host}\n`;
              output += `Áî®Êà∑: ${connection.config.username}\n`;
              output += `Áä∂ÊÄÅ: ${connection.status}\n`;
              output += `ÊúÄÂêéÊâßË°å: ${this.formatTimeDifference(info.lastCheck)}\n`;
              output += "\n---\n\n";
            }
          }
          
          return {
            content: [{
              type: "text",
              text: output
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Ëé∑ÂèñÂêéÂè∞‰ªªÂä°Êó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // ÂÅúÊ≠¢ÊâÄÊúâÂêéÂè∞‰ªªÂä°
    this.server.tool(
      "stopAllBackgroundTasks",
      {},
      () => {
        try {
          const count = this.backgroundExecutions.size;
          
          if (count === 0) {
            return {
              content: [{
                type: "text",
                text: "ÂΩìÂâçÊ≤°ÊúâËøêË°å‰∏≠ÁöÑÂêéÂè∞‰ªªÂä°"
              }]
            };
          }
          
          // ÂÅúÊ≠¢ÊâÄÊúâÂêéÂè∞‰ªªÂä°
          for (const id of this.backgroundExecutions.keys()) {
            this.stopBackgroundExecution(id);
          }
          
          return {
            content: [{
              type: "text",
              text: `Â∑≤ÂÅúÊ≠¢ÊâÄÊúâ ${count} ‰∏™ÂêéÂè∞‰ªªÂä°`
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `ÂÅúÊ≠¢ÊâÄÊúâÂêéÂè∞‰ªªÂä°Êó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
  }
  
  /**
   * Ê≥®ÂÜåÁªàÁ´Ø‰∫§‰∫íÂ∑•ÂÖ∑
   */
  private registerTerminalTools() {
    // ÂàõÂª∫ÁªàÁ´Ø‰ºöËØù
    this.server.tool(
      "mcp_ssh_mcp_createTerminalSession",
      {
        connectionId: z.string(),
        rows: z.number().optional(),
        cols: z.number().optional(),
        term: z.string().optional(),
      },
      async (params) => {
        try {
          const { connectionId, rows, cols, term } = params;
          const sessionId = await this.sshService.createTerminalSession(connectionId, { rows, cols, term });
          
          // ËÆæÁΩÆÁªàÁ´ØÊï∞ÊçÆÁõëÂê¨Âô®
          const unsubscribeData = this.sshService.onTerminalData((event) => {
            if (event.sessionId === sessionId) {
              // Â∫îÁî®ËæìÂá∫ÈïøÂ∫¶ÈôêÂà∂
              const limitedData = this.limitOutputLength(event.data);

              (this.server as any).sendEvent('terminal_data', {
                sessionId: event.sessionId,
                data: limitedData,
                human: limitedData
              });
            }
          });
          
          // ÂΩìÁªàÁ´ØÂÖ≥Èó≠Êó∂ÔºåÂèñÊ∂àËÆ¢ÈòÖ
          const unsubscribeClose = this.sshService.onTerminalClose((event) => {
            if (event.sessionId === sessionId) {
              unsubscribeData();
              unsubscribeClose(); // ‰πüÂèñÊ∂àËá™Ë∫´ÁöÑËÆ¢ÈòÖ
              (this.server as any).sendEvent('terminal_closed', {
                sessionId: event.sessionId,
                human: `ÁªàÁ´Ø‰ºöËØù ${sessionId} Â∑≤ÂÖ≥Èó≠`
              });
            }
          });
          
          return {
            content: [{
              type: "text",
              text: `Â∑≤ÂàõÂª∫ÁªàÁ´Ø‰ºöËØù ${sessionId}`
            }],
            sessionId
          };
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          console.error(`ÂàõÂª∫ÁªàÁ´Ø‰ºöËØùÂ§±Ë¥•:`, error);
          return {
            content: [{
              type: "text",
              text: `ÂàõÂª∫ÁªàÁ´Ø‰ºöËØùÂ§±Ë¥•: ${errorMessage}`
            }],
            isError: true
          };
        }
      }
    );
    
    // ÂêëÁªàÁ´ØÂÜôÂÖ•Êï∞ÊçÆ
    this.server.tool(
      "mcp_ssh_mcp_writeToTerminal",
      {
        sessionId: z.string(),
        data: z.string()
      },
      async (params) => {
        try {
          const { sessionId, data } = params;
          const success = await this.sshService.writeToTerminal(sessionId, data);
          
          return {
            content: [{
              type: "text",
              text: success ? `Êï∞ÊçÆÂ∑≤ÂèëÈÄÅÂà∞ÁªàÁ´Ø ${sessionId}` : `Êï∞ÊçÆÂèëÈÄÅÂ§±Ë¥•`
            }],
            success
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `ÂêëÁªàÁ´ØÂÜôÂÖ•Êï∞ÊçÆÊó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
  }

  /**
   * Ê≥®ÂÜåÈößÈÅìÁÆ°ÁêÜÂ∑•ÂÖ∑
   */
  private registerTunnelTools(): void {
    // ÂàõÂª∫ÈößÈÅì
    this.server.tool(
      "createTunnel",
      {
        connectionId: z.string(),
        localPort: z.number(),
        remoteHost: z.string(),
        remotePort: z.number(),
        description: z.string().optional()
      },
      async ({ connectionId, localPort, remoteHost, remotePort, description }) => {
        try {
          const connection = this.sshService.getConnection(connectionId);
          
          if (!connection) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connectionId} ‰∏çÂ≠òÂú®`
              }],
              isError: true
            };
          }
          
          if (connection.status !== ConnectionStatus.CONNECTED) {
            return {
              content: [{
                type: "text",
                text: `ÈîôËØØ: ËøûÊé• ${connection.name || connectionId} Êú™ËøûÊé•`
              }],
              isError: true
            };
          }
          
          // ÂàõÂª∫ÈößÈÅì
          const tunnelId = await this.sshService.createTunnel({
            connectionId,
            localPort,
            remoteHost,
            remotePort,
            description
          });
          
          return {
            content: [{
              type: "text",
              text: `ÈößÈÅìÂ∑≤ÂàõÂª∫\nÊú¨Âú∞Á´ØÂè£: ${localPort}\nËøúÁ®ã: ${remoteHost}:${remotePort}\nÈößÈÅìID: ${tunnelId}`
            }],
            tunnelId
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `ÂàõÂª∫ÈößÈÅìÊó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // ÂÖ≥Èó≠ÈößÈÅì
    this.server.tool(
      "closeTunnel",
      {
        tunnelId: z.string()
      },
      async ({ tunnelId }) => {
        try {
          const success = await this.sshService.closeTunnel(tunnelId);
          
          if (success) {
            return {
              content: [{
                type: "text",
                text: `ÈößÈÅì ${tunnelId} Â∑≤ÂÖ≥Èó≠`
              }]
            };
          } else {
            return {
              content: [{
                type: "text",
                text: `ÂÖ≥Èó≠ÈößÈÅì ${tunnelId} Â§±Ë¥•`
              }],
              isError: true
            };
          }
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `ÂÖ≥Èó≠ÈößÈÅìÊó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
    
    // ÂàóÂá∫ÊâÄÊúâÈößÈÅì
    this.server.tool(
      "listTunnels",
      {},
      () => {
        try {
          const tunnels = this.sshService.getTunnels();
          
          if (tunnels.length === 0) {
            return {
              content: [{
                type: "text",
                text: "ÂΩìÂâçÊ≤°ÊúâÊ¥ªË∑ÉÁöÑÈößÈÅì"
              }]
            };
          }
          
          let output = "Ê¥ªË∑ÉÁöÑÈößÈÅì:\n\n";
          
          for (const tunnel of tunnels) {
            const connection = this.sshService.getConnection(tunnel.connectionId);
            output += `ID: ${tunnel.id}\n`;
            output += `Êú¨Âú∞Á´ØÂè£: ${tunnel.localPort}\n`;
            output += `ËøúÁ®ã: ${tunnel.remoteHost}:${tunnel.remotePort}\n`;
            
            if (connection) {
              output += `ËøûÊé•: ${connection.name || connection.id} (${connection.config.host})\n`;
            }
            
            if (tunnel.description) {
              output += `ÊèèËø∞: ${tunnel.description}\n`;
            }
            
            output += "\n---\n\n";
          }
          
          return {
            content: [{
              type: "text",
              text: output
            }],
            tunnels
          };
        } catch (error) {
          return {
            content: [{
              type: "text",
              text: `Ëé∑ÂèñÈößÈÅìÂàóË°®Êó∂Âá∫Èîô: ${error instanceof Error ? error.message : String(error)}`
            }],
            isError: true
          };
        }
      }
    );
  }

  /**
   * ÂÖ≥Èó≠ÊâÄÊúâËøûÊé•Âπ∂Ê∏ÖÁêÜËµÑÊ∫ê
   */
  public async close(): Promise<void> {
    try {
      // ÂÅúÊ≠¢ÊâÄÊúâÂêéÂè∞‰ªªÂä°
      for (const id of this.backgroundExecutions.keys()) {
        this.stopBackgroundExecution(id);
      }
      
      // ÂÖ≥Èó≠ÊâÄÊúâÈößÈÅì
      const tunnels = this.sshService.getTunnels();
      for (const tunnel of tunnels) {
        await this.sshService.closeTunnel(tunnel.id!);
      }

      // ÂÖ≥Èó≠ÊâÄÊúâÁªàÁ´Ø‰ºöËØù
      const sessions = this.sshService.getAllTerminalSessions();
      for (const session of sessions) {
        await this.sshService.closeTerminalSession(session.id);
      }
      
      // Êñ≠ÂºÄÊâÄÊúâËøûÊé•
      const connections = await this.sshService.getAllConnections();
      for (const connection of connections) {
        if (connection.status === ConnectionStatus.CONNECTED) {
          await this.sshService.disconnect(connection.id);
        }
      }
      
      // ÂÖ≥Èó≠SSHÊúçÂä°
      await this.sshService.close();
      
      // Ê∏ÖÁ©∫Ê¥ªË∑ÉËøûÊé•ËÆ∞ÂΩï
      this.activeConnections.clear();
      this.backgroundExecutions.clear();
    } catch (error) {
      console.error('ÂÖ≥Èó≠SSH MCPÊó∂Âá∫Èîô:', error);
      throw error;
    }
  }

  /**
   * Â§ÑÁêÜÈïøÊñáÊú¨ËæìÂá∫ÔºåË∂ÖËøáÈôêÂà∂Êó∂Êà™ÂèñÂâçÂêéÈÉ®ÂàÜ
   */
  private limitOutputLength(text: string, maxLength: number = 10000, targetLength: number = 6000): string {
    if (text.length <= maxLength) {
      return text;
    }

    // ËÆ°ÁÆó‰øùÁïôÂâçÂêéÈÉ®ÂàÜÁöÑÈïøÂ∫¶
    const halfTargetLength = Math.floor(targetLength / 2);
    
    // ÊèêÂèñÂâçÂêéÈÉ®ÂàÜ
    const prefix = text.substring(0, halfTargetLength);
    const suffix = text.substring(text.length - halfTargetLength);
    
    // Ê∑ªÂä†ÁúÅÁï•ÊåáÁ§∫ÂèäÂ¶Ç‰ΩïËé∑ÂèñÂÆåÊï¥ËæìÂá∫ÁöÑÊèêÁ§∫
    const omittedLength = text.length - targetLength;
    const omittedMessage = `\n\n... Â∑≤ÁúÅÁï• ${omittedLength} ‰∏™Â≠óÁ¨¶ ...\n` +
                           `Â¶ÇÈúÄÊü•ÁúãÂÆåÊï¥ËæìÂá∫ÔºåÂèØÊ∑ªÂä†‰ª•‰∏ãÂèÇÊï∞Ôºö\n` +
                           `- ‰ΩøÁî® > output.txt Â∞ÜËæìÂá∫‰øùÂ≠òÂà∞Êñá‰ª∂\n` +
                           `- ‰ΩøÁî® | head -n Êï∞Â≠ó Êü•ÁúãÂâçÂá†Ë°å\n` +
                           `- ‰ΩøÁî® | tail -n Êï∞Â≠ó Êü•ÁúãÂêéÂá†Ë°å\n` +
                           `- ‰ΩøÁî® | grep "ÂÖ≥ÈîÆËØç" ËøáÊª§ÂåÖÂê´ÁâπÂÆöÂÜÖÂÆπÁöÑË°å\n\n`;
    
    // ÁªÑÂêàËæìÂá∫
    return prefix + omittedMessage + suffix;
  }
}